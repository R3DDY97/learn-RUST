* Rust 

** Variables
   + let 
   + mut
   + const
 

** Data Types

   * Scalar  - represents single value

     + Integer

      - Length 	Signed 	Unsigned

	8-bit 	i8 	u8
	16-bit 	i16 	u16
	32-bit 	i32 	u32   -- Default 32bit(faster even for 64bit machine)
	64-bit 	i64 	u64
	arch 	isize 	usize
	
      - Number literals      Example

	  Decimal 	      98_222
	  Hex 	              0xff
	  Octal 	      0o77
	  Binary 	      0b1111_0000
	  Byte (u8 only)      b'A'

     + Floating
        - Types
          + f32 -- single precision 
	  + f64 -- double precision (default)

     + Boolean
       - bool
	 + false
	 + true

     + Character
       - char
	 + should be in SNIGLE quote and Strings will be in Double Quotes
	 + Unicode scalar values ranging from U+0000 to U+D7FF  and U+E000 to U+10FFFF
	   
	 
   
   * Compound
     
     + Tuples(tup) 
       - Holds multiple elements of DIFFERENT data types
       - Destructure
       - '.'
       - let num_tup: (u32, f64, i8) = (24, 54.34, 5)
	 num_tup.0 = 24
	 let (x, y, z) = num_tup
	 

     + Arrays(array) 
        - Holds elements of SAME data type
	- FIXED length once declared
	- let num_array = [9, 8, 7, 6, 5]
	  num_array[0] = 9
	  num_array[1] = 8

    
     

** Functions
   + *fn* keyword defines function
   + ONE MAIN function per program
   + *parmeters* data-type show be annotated 
   + *Statements* are instructions that perform some action and do not return a value. 
   + *Expressions* evaluate to a resulting value and no ending semicolons
 

** Control Flows
   * *if* Expressions
     + if condition { block of statements and expression}
     + can use *if* as expression in assigning value to variable
     + if and else return block expression should be of same data-type
   
   * *loops*
     + need to use break to stop infinte loops

   * *while*
      similar
   * *for*
     similar



       
     


** ownership
   + To handle stack and heap properly
   + It manages heap and efficient use of memory to prevent overflow n ran out of space
   + No Need for *Garbage Collector* 
   + Using *drop* method, it returns memory to OS like Resource Acquisition Is Initialization (RAII) in C++
   + Variable scopes
   + "String" Data-type -- Stored in Heap
     - They are mutable 
     - string literals can be converted to String - String::from(string_literal)

   + terms and concepts
     - *clone*
     - *move*
     - *Drop*
     - *Copy*
 

** References and Borrowing
   - *&* - denotes *references*
   - It  refers to some value without taking ownership of it
   - *borrowing* is having references as function parameters
   - reference variables are immutables by default 
   - can make reference variable mutable by using *&mut* for mutable variable
     but can only use that variable *once* for reference -> to prevent  *data race*
     and cant use both mutable and normal reference simultaneously in same scope
   - Can make mutiple mutable references if those are in different scopes or code blocks({......})
   - NO Dangling references
   - either (but not both of) one mutable reference or any number of immutable references.
   - References must always be valid.


** Slice data-type
   
   -denoted as *&str* for string slices
   - There can be slices for arrays too.


   
 


** Struc
   - _Structs let you create custom types that are meaningful_
   - syntax -> *struct struct_name {fields as k:v}*
   - *field init shorthand*
   - *struct update syntax*
   - *tuple structs*
   - *unit-like structs*
   - *derive*
     

** Methods 
   - syntax -> similar to function but used along with *struct/enum/trait object*
   - its 1st arg is *self*
   - *impl* -> (implementation)
   - *method syntax*
   - *automatic referencing and dereferencing*
   - *impl blocks*
   - *associated functions* and *::* -> namespace


** Enums
