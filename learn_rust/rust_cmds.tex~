% Created 2018-04-22 Sun 20:55
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\date{\today}
\title{Brief Notes on Rust Programming}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 25.3.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\setcounter{tocdepth}{1}
\tableofcontents

written while reading  \href{https://doc.rust-lang.org/book/second-edition/index.html}{The Rust Programming Language}  - \emph{R3DDY97}


\section{Variables}
\label{sec-1}

\begin{itemize}
\item let:- assigns variable

\item mut:- makes variable mutable

\item const:- assigned varialbe is constant lifetime
\end{itemize}



\section{Data Types}
\label{sec-2}

\subsection{Scalar  - represents single value}
\label{sec-2-1}

\begin{enumerate}
\item Integer
\texttt{Interger types}

\begin{center}
\begin{tabular}{lll}
Length & signed & Unsigned\\
\hline
8-bit & i8 & u8\\
 &  & \\
16-bit & i16 & u16\\
 &  & \\
32-bit & i32 & u32\\
 &  & \\
64-bit & i64 & u64\\
 &  & \\
arch & isize & usize\\
 &  & \\
\end{tabular}
\end{center}

\texttt{Examples of Integer types}

\begin{center}
\begin{tabular}{ll}
Number literals & Example\\
\hline
Decimal & 9822\\
Hex & 0xff\\
Octal & 0o77\\
Binary & 0b1111000\\
Byte (u8 only) & b'A'\\
\end{tabular}
\end{center}

\item Floating

\begin{itemize}
\item f32 -- single precision

\item f64 -- double precision (default)
\end{itemize}

\item Boolean

\begin{itemize}
\item bool

\begin{itemize}
\item false

\item true
\end{itemize}
\end{itemize}

\item Character

\begin{itemize}
\item char

\begin{itemize}
\item should be in SINGLE quote and Strings will be in Double Quotes

\item Unicode scalar values ranging from U+0000 to U+D7FF  and U+E000 to U+10FFFF
\end{itemize}
\end{itemize}
\end{enumerate}


\subsection{Compound}
\label{sec-2-2}

\begin{enumerate}
\item Tuples(tup) 

\begin{itemize}
\item Holds multiple elements of DIFFERENT data types

\item Destructure

\item '.'

\begin{verbatim}
let num_tup: (u32, f64, i8) = (24, 54.34, 5)
 num_tup.0 = 24
 let (x, y, z) = num_tup
\end{verbatim}
\end{itemize}

\item Arrays(array) 

\begin{itemize}
\item Holds elements of SAME data type

\item FIXED length once declared

\begin{verbatim}
let num_array = [9, 8, 7, 6, 5]
num_array~[0]~ = 9
num_array~[1]~ = 8
\end{verbatim}
\end{itemize}
\end{enumerate}


\section{Functions}
\label{sec-3}

\begin{enumerate}
\item \emph{fn} keyword defines function

\item ONE MAIN function per program

\item parmeters data-type show be annotated

\item Statements are instructions that perform some action and do not return a value.

\item Expressions evaluate to a resulting value and no ending semicolons
\end{enumerate}


\section{Control Flows}
\label{sec-4}

\begin{enumerate}
\item if Expressions

\begin{enumerate}
\item if condition \{ block of statements and expression\}

\item can use \emph{if} as expression in assigning value to variable

\item if and else return block expression should be of same data-type
\end{enumerate}

\item loops ->  need to use break to stop infinte loops

\item while --  similar

\item for --  similar
\end{enumerate}



\section{Ownership}
\label{sec-5}

\begin{enumerate}
\item To handle stack and heap properly

\item It manages heap and efficient use of memory to prevent overflow n ran out of space

\item No Need for Garbage Collector

\item Using drop method, it returns memory to OS like Resource Acquisition Is Initialization (RAII) in C++

\item Variable scopes

\item "String" Data-type -- Stored in Heap

\begin{itemize}
\item They are mutable

\item string literals can be converted to String - String::from(string$_{\text{literal}}$)
\end{itemize}

\item terms and concepts
\begin{enumerate}
\item \emph{clone}
\item \emph{move}
\item \emph{Drop}
\item \emph{Copy}
\end{enumerate}
\end{enumerate}


\section{References and Borrowing}
\label{sec-6}

\begin{enumerate}
\item \emph{\&} - denotes references

\item It  refers to some value without taking ownership of it

\item \emph{borrowing} is having references as function parameters

\item reference variables are immutables by default

\item can make reference variable mutable by using \verb~&mut~ for mutable variable
but can only use that variable \verb~once~ for reference -> to prevent  \emph{data race}
and cant use both mutable and normal reference simultaneously in same scope

\item Can make mutiple mutable references if those are in different scopes or code blocks(\{\ldots{}\ldots{}\})

\item NO Dangling references

\item either (but not both of) one mutable reference or any number of immutable references.

\item References must always be valid.
\end{enumerate}


\section{Slice data-type}
\label{sec-7}

\begin{enumerate}
\item denoted as \verb~&str~  for string slices

\item There can be slices for arrays too.
\end{enumerate}


\section{Struc}
\label{sec-8}

\begin{enumerate}
\item Structs let you create custom types that are meaningful

\item syntax     \verb~struct struct_name {fields as k:v}~

\item field init shorthand

\item struct update syntax

\item tuple structs

\item unit-like structs

\item derive \verb~#[derive(Debug)]~

\item can create methods to enums
\end{enumerate}


\section{Matches}
\label{sec-9}

\begin{enumerate}
\item exhaustive

\item we must exhaust every last possibility in order for the code to be valid

\item Especially in the case of Option<T>, when Rust prevents us from forgetting to explicitly handle the None case

\item it protects us from assuming that we have a value when we might have null -> billion-dollar mistake.

\item \_ place holder -> to simplyfy to exclude remaining possibilities
\end{enumerate}


\section{if let}
\label{sec-10}

\begin{enumerate}
\item syntax sugar for a \emph{match} that runs code when the value matches one pattern and then ignores all other values.

\item can use \emph{else} after \emph{if let}
\end{enumerate}


\section{Modules}
\label{sec-11}

\begin{itemize}
\item Its a \emph{namespace} that contains definitions of functions or types

\item Can choose whether those definitions are visible outside their module (public) or not (private)

\item \emph{mod} keyword declares a new module

\item \emph{use} keyword brings modules, or the definitions inside modules, into scope to easily refer to them
\end{itemize}


\section{Use}
\label{sec-12}

\begin{itemize}
\item \emph{use} keyword shortens lengthy function calls by bringing the modules of the function you want to call into scope

\item will work for \emph{enums} also

\item glob operator -> '*'

\item \emph{super}
\end{itemize}


\section{Collections}
\label{sec-13}

\subsection{vector}
\label{sec-13-1}

\begin{enumerate}
\item Vec<T>

\item syntax   \verb~let v: Vec<i32> = Vec::new();~

\item Its stored in heaps

\item simple way    \verb~let v = vec![1, 2, 3];~

\item \emph{push} adds new elements in mutable vector  and \emph{pop} removes last element

\item Dropping a Vector Drops Its Elements
\begin{itemize}
\item When vector is out of scope, it will be dropped and memory is freed

\begin{verbatim}
#![allow(unused_variables)]
fn main() {
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v

} // <- v goes out of scope and is freed here
}
\end{verbatim}
\end{itemize}

\item \emph{get} is used to access element or vector[n] 

\begin{verbatim}
#![allow(unused_variables)]
fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
let third: Option<&i32> = v.get(2);
}
\end{verbatim}

\item can’t have mutable and immutable references in the same scope
Having immutable reference to  a vector element and adding an element to the end, won’t work

\item \emph{dereference operator (*)}

\item \emph{enum} can be used to store values of different types in one vector
\end{enumerate}


\subsection{String}
\label{sec-13-2}

\begin{enumerate}
\item Growable, mutable, owned, UTF-8 encoded string type.
When Rustaceans refer to “strings” in Rust, 
they usually mean the String and the string slice \&str types, not just one of those types

\item Most of syntax similar to vector

\verb~let mut s = String::new();~

\item \verb~to_string()~  or \verb~String::from()~

\verb~let data = "initial contents";~

\verb~let s = data.to_string();~

\item \emph{Updating a String}

\begin{enumerate}
\item \verb~push_str~ :- appends a string slice to a String

\item \emph{push} :- adds one character to a String

\item \emph{+} adds reference string to a string 
and uses \emph{deref coercion} 

\verb~let s3 = s1 + &s2;~

\item format!
The format! macro works in the same way as println!.
Instead of printing the output to the screen, it returns a String with the contents

\verb~let s = format!("{}-{}-{}", s1, s2, s3);~

\item Indexing is complicated coz of Unicode way of storing in memory

\item Iterate using .chars() or .bytes() methods
\end{enumerate}
\end{enumerate}


\subsection{Hash maps}
\label{sec-13-3}

\begin{itemize}
\item HashMap<K, V>

\item stores a mapping of keys of type \emph{K} to values of type \emph{V}.

\item It does this via a \emph{hashing function}
\end{itemize}
% Emacs 25.3.1 (Org mode 8.2.10)
\end{document}
